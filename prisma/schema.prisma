// Prisma schema for The Funny production-ready MVP

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  PROMOTER
  VENUE
  COMEDIAN
  FAN
}

enum GigType {
  OPEN_MIC
  BOOKED_SHOW
  PAID_GIG
}

enum LeadStatus {
  NEW
  REVIEW
  APPROVED
  REJECTED
  DUPLICATE
}

enum GigStatus {
  DRAFT
  PENDING
  PUBLISHED
  ARCHIVED
}

enum SignUpMethod {
  WALKUP
  ONLINE_FORM
  DM
  EMAIL
  OTHER
}

enum ApplicationStatus {
  APPLIED
  SHORTLISTED
  REJECTED
  BOOKED
  CANCELLED
}

enum PayoutStatus {
  NONE
  HELD
  PAID
  REFUNDED
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String
  role         Role      @default(FAN)
  createdAt    DateTime  @default(now())

  profile              Profile?
  ownedVenues          Venue[]       @relation("VenueOwner")
  promoter             Promoter?
  gigsCreated          Gig[]         @relation("GigPromoter")
  applications         Application[] @relation("GigApplications")
  bookings             Booking[]     @relation("GigBookings")
  verificationRequests VerificationRequest[]
  messagesSent         Message[]     @relation("MessageSender")
  messagesReceived     Message[]     @relation("MessageRecipient")
  reviewedRequests     VerificationRequest[] @relation("VerificationReviewer")
  emailTokens          EmailVerificationToken[]

  @@map("users")
}

model Profile {
  id        String  @id @default(cuid())
  userId    String  @unique
  stageName String?
  bio       String?
  avatarUrl String?
  city      String?
  region    String?
  country   String?
  links     Json?
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Venue {
  id        String   @id @default(cuid())
  ownerId   String
  name      String
  address   String?
  lat       Float?
  lng       Float?
  phone     String?
  website   String?
  gigs      Gig[]
  owner     User     @relation("VenueOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("venues")
}

model Promoter {
  id      String @id @default(cuid())
  userId  String @unique
  orgName String?
  website String?
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  gigs    Gig[]

  @@map("promoters")
}

model Gig {
  id             String    @id @default(cuid())
  type           GigType   @default(OPEN_MIC)
  title          String
  description    String
  venueId        String?
  promoterId     String?
  startsAt       DateTime
  endsAt         DateTime?
  isRecurring    Boolean   @default(false)
  recurrenceRule String?
  payMin         Int?
  payMax         Int?
  bringer        Boolean   @default(false)
  signUpMethod   SignUpMethod @default(WALKUP)
  externalUrl    String?
  status         GigStatus @default(DRAFT)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  venue          Venue?    @relation(fields: [venueId], references: [id])
  promoter       Promoter? @relation(fields: [promoterId], references: [id])
  applications   Application[]
  bookings       Booking[]
  leads          Lead[]

  @@map("gigs")
  @@index([status])
  @@index([type, status])
}

model Application {
  id          String            @id @default(cuid())
  gigId       String
  comedianId  String
  status      ApplicationStatus @default(APPLIED)
  notes       String?
  createdAt   DateTime          @default(now())

  gig         Gig               @relation(fields: [gigId], references: [id], onDelete: Cascade)
  comedian    User              @relation("GigApplications", fields: [comedianId], references: [id], onDelete: Cascade)

  @@map("applications")
  @@index([gigId, comedianId])
}

model Booking {
  id           String       @id @default(cuid())
  gigId        String
  comedianId   String
  amountCents  Int?
  currency     String?      @default("usd")
  payoutStatus PayoutStatus @default(NONE)

  gig          Gig          @relation(fields: [gigId], references: [id], onDelete: Cascade)
  comedian     User         @relation("GigBookings", fields: [comedianId], references: [id], onDelete: Cascade)

  @@map("bookings")
}

model VerificationRequest {
  id          String             @id @default(cuid())
  userId      String
  docUrl      String?
  note        String?
  status      VerificationStatus @default(PENDING)
  reviewedBy  String?
  reviewedAt  DateTime?

  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer    User?              @relation("VerificationReviewer", fields: [reviewedBy], references: [id])

  @@map("verification_requests")
}

model Message {
  id           String   @id @default(cuid())
  threadId     String
  senderId     String
  recipientId  String
  body         String
  createdAt    DateTime @default(now())

  sender       User     @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  recipient    User     @relation("MessageRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@map("messages")
  @@index([threadId])
}

model Lead {
  id          String     @id @default(cuid())
  source      String
  url         String
  title       String?
  raw         Json?
  normalized  Json?
  seenHash    String?
  status      LeadStatus @default(NEW)
  gigId       String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  gig         Gig?       @relation(fields: [gigId], references: [id])

  @@unique([url])
  @@map("leads")
}

model AllowlistSource {
  id            String  @id @default(cuid())
  domain        String  @unique
  label         String
  enabled       Boolean @default(true)
  lastCheckedAt DateTime?

  @@map("allowlist_sources")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_verification_tokens")
}

model AdSlot {
  id        String   @id @default(cuid())
  page      String
  placement String
  html      String?
  imageUrl  String?
  linkUrl   String?
  active    Boolean  @default(true)
  priority  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([page, placement, active])
  @@map("ad_slots")
}
